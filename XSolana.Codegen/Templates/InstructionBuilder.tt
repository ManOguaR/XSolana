<#@ template language="C#" hostspecific="true" debug="false" #>
<#@ output extension=".g.cs" #>
<#@ assembly name="XSolana.Codegen" #>
<#@ import namespace="XSolana.Conventions" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="XSolana.Conventions" #>

<#
var program = this.Host.ResolveParameterValue("", "", "Model") as ProgramDefinition;
#>
// <auto-generated />
using Solnet.Programs;
using Solnet.Programs.Utilities;
using Solnet.Wallet;
using Solnet.Rpc.Models;
using System.Collections.Generic;

namespace Generated.<#= program.Name #>
{
<#
foreach (var instr in program.Instructions)
{
    var className = $"{ToPascalCase(instr.Name)}Builder";
#>
    public static class <#= className #>
    {
        public static TransactionInstruction Build(
<#
    // Cuentas
    foreach (var account in instr.Accounts)
    {
#>            PublicKey <#= account.Name #>,
<#
    }

    // Args
    foreach (var arg in instr.Args)
    {
#>            <#= ResolveCSharpType(arg.Type) #> <#= arg.Name #>,
<#
    }
#>            PublicKey programId
        )
        {
            var keys = new List<AccountMeta>
            {
<#
    foreach (var account in instr.Accounts)
    {
#>                AccountMeta.<#= (account.IsSigner ? "WritableSigner" : (account.IsMut ? "Writable" : "Readonly")) #>(<#= account.Name #>, <#= account.IsSigner.ToString().ToLower() #>),
<#
    }
#>            };

            // TODO: Serialize args using Borsh or similar
            var data = new byte[] { /* serialized instruction data */ };

            return new TransactionInstruction
            {
                ProgramId = programId,
                Keys = keys,
                Data = data
            };
        }
    }
<#
}
#>
}
<#+
    private string ToPascalCase(string name)
    {
        if (string.IsNullOrWhiteSpace(name)) return name;
        return char.ToUpperInvariant(name[0]) + name.Substring(1);
    }

    private string ResolveCSharpType(string type)
    {
        switch (type)
        {
            case "u8": return "byte";
            case "u16": return "ushort";
            case "u32": return "uint";
            case "u64": return "ulong";
            case "i8": return "sbyte";
            case "i16": return "short";
            case "i32": return "int";
            case "i64": return "long";
            case "bool": return "bool";
            case "string": return "string";
            case "publicKey": return "PublicKey";
            default: return "object"; // fallback
        }
    }
#>