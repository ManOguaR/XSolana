using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using XSolana.Builders.Extensions;
using XSolana.Conventions;

namespace XSolana.Builders
{
    /// <summary>
    /// Base class for code builders.
    /// </summary>
    public abstract class CodeBuilderBase
    {
        private int _indent = 0;
        private readonly List<int> _namespaceSections = [];
        private static readonly string[] TypeTypes = { "class", "struct", "interface" };

        /// <summary>
        /// The name of the class being built.
        /// </summary>
        protected string TypeName { get; set; }

        /// <summary>
        /// The namespace of the class being built.
        /// </summary>
        protected string Namespace { get; set; }

        /// <summary>
        /// The list of using directives to be included in the generated code.
        /// </summary>
        protected string[] Includes { get; set; }

        /// <summary>
        /// Returns the current indentation level.
        /// </summary>
        protected int Indentation => _indent;

        /// <summary>
        /// The code being built.
        /// </summary>
        protected StringBuilder Code { get; } = new StringBuilder();

        /// <summary>
        /// Initializes a new instance of the class.
        /// </summary>
        protected CodeBuilderBase(string className, string @namespace)
        {
            TypeName = className.ToPascalCase();
            Namespace = @namespace.ToPascalCase();
        }

        /// <summary>
        /// Partially transforms a <see cref="ProgramDefinition"/> into C# code.
        /// </summary>
        /// <param name="program">A <see cref="ProgramDefinition"/> object representing the IDL program.</param>
        /// <returns>Returns a string containing the generated C# code.</returns>
        public abstract string TransformText(ProgramDefinition program);

        /// <summary>
        /// Adds an indentation level.
        /// </summary>
        protected void IndentAdd() => _indent++;

        /// <summary>
        /// Removes an indentation level.
        /// </summary>
        protected void IndentLess()
        {
            if (_indent > 0)
                _indent--;
        }

        /// <summary>
        /// Returns the current indentation string.
        /// </summary>
        /// <returns>The current indentation string, which consists of tabs.</returns>
        protected string Indent()
        {
            var indent = new string('\t', _indent);
            return indent;
        }

        /// <summary>
        /// Writes the end of a block of code with an optional suffix.
        /// </summary>
        /// <param name="suffix">Optional. A string representing the suffix to be added at the end of the block.</param>
        protected void EndBlock(string suffix = "")
        {
            IndentLess();
            WriteLine($"}}{suffix}");
        }

        /// <summary>
        /// Begins a block of code with an opening brace and increases the indentation level.
        /// </summary>
        protected void BeginBlock()
        {
            WriteLine("{");
            IndentAdd();
        }

        /// <summary>
        /// Writes a line of code with the current indentation level.
        /// </summary>
        /// <param name="line">A string representing the line of code to be written.
        /// This string will be prefixed with the current indentation level.</param>
        /// <param name="indentation"> Optional. An integer representing the indentation level
        /// to be used for this line. If not provided, the current indentation level will be used.</param>
        /// <returns>A string representing the line of code that was written.</returns>
        protected string WriteLine(string line, int indentation = -1)
        {
            int tmp = _indent;

            if (indentation > -1)
                _indent = indentation;

            Code.AppendLine($"{Indent()}{line}");

            if (indentation > -1)
                _indent = tmp;

            return line;
        }

        /// <summary>
        /// Writes a empty line.
        /// </summary>
        protected void WriteReturn() => Code.AppendLine();

        /// <summary>
        /// Writes a file header for the generated code.
        /// </summary>
        protected void WriteFileHeader()
        {
            _indent = 0;
            WriteLine("// <auto-generated />");
            WriteReturn();
            if (Includes != null && Includes.Length > 0)
            {
                foreach (var include in Includes)
                {
                    WriteLine($"using {include};");
                }
            }
            WriteReturn();
        }

        /// <summary>
        /// Writes the initial namespace section
        /// </summary>
        protected void BeginNamespace()
        {
            if (_namespaceSections.Contains(_indent))
                IndentAdd();

            Code.AppendLine($"namespace {Namespace}");
            Code.AppendLine("{");

            _namespaceSections.Add(_indent);
            IndentAdd();
        }

        /// <summary>
        /// Writes the closing namespace section
        /// </summary>
        protected void EndNamespace()
        {

            while (!_namespaceSections.Contains(_indent))
                IndentLess();

            _namespaceSections.Remove(_indent);

            Code.AppendLine("}");
        }

        /// <summary>
        /// Writes an interface for the generated code.
        /// </summary>
        /// <param name="name">Optional. A string representing the name of the interface to be generated.</param>
        /// <param name="isInternal">A boolean indicating whether the interface should be internal or public.</param>
        protected void BeginInterface(string name = null, bool isInternal = false)
            => BeginType(name, "interface", isInternal);

        /// <summary>
        /// Writes a class for the generated code.
        /// </summary>
        /// <param name="name">Optional. A string representing the name of the class to be generated.</param>
        /// <param name="isInternal">A boolean indicating whether the class should be internal or public.</param>
        /// <param name="isStatic">A boolean indicating whether the class should be static.
        /// Cannot be used with abstract/>.</param>
        /// <param name="isAbstract">A boolean indicating whether the class should be abstract.
        /// Cannot be used with static/>.</param>
        protected void BeginClass(string name = null, bool isInternal = false, bool isStatic = false, bool isAbstract = false)
            => BeginType(name, "class", isInternal, isStatic, isAbstract);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="name"></param>
        /// <param name="isInternal"></param>
        protected void BeginStruct(string name = null, bool isInternal = false)
            => BeginType(name, "struct", isInternal);

        /// <summary>
        /// Writes a type for the generated code.
        /// </summary>
        /// <param name="name">Optional. A string representing the name of the class to be generated.
        /// If not provided, the default class name will be used.</param>
        /// <param name="type">Optional. A string representing the type (class, struct or interface) of the type to be generated.
        /// If not provided, a class will be written.</param>
        /// <param name="isInternal">A boolean indicating whether the type should be internal or public.</param>
        /// <param name="isStatic">A boolean indicating whether the type should be static.
        /// Can only be used with classes. Cannot be used with abstract/>.</param>
        /// <param name="isAbstract">A boolean indicating whether the type should be abstract.</param>
        protected void BeginType(string name = null, string type = "class", bool isInternal = false, bool isStatic = false, bool isAbstract = false)
        {
            if (string.IsNullOrEmpty(name) && string.IsNullOrEmpty(TypeName))
                throw new ArgumentException("Class name cannot be null or empty.");

            if(string.IsNullOrEmpty(type) || !TypeTypes.Contains(type))
                throw new ArgumentException("Invalid type. Only 'class', 'struct', or 'interface' are allowed.");

            var typeName = string.IsNullOrEmpty(name)
                ? TypeName : name;

            bool isClass = type.Equals("class", StringComparison.OrdinalIgnoreCase);

            WriteLine($"{(isInternal ? "internal" : "public")}{(isClass ? (isStatic ? " static" : isAbstract ? " abstract" : "") : "")} {type} {typeName}");
            WriteLine("{");
            IndentAdd();
        }

        /// <summary>
        /// Writes the closing type section
        /// </summary>
        protected void EndType()
        {
            IndentLess();
            Code.AppendLine("}");
        }
    }
}